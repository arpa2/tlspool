# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_tlspool')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_tlspool')
    _tlspool = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_tlspool', [dirname(__file__)])
        except ImportError:
            import _tlspool
            return _tlspool
        if fp is not None:
            try:
                _mod = imp.load_module('_tlspool', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _tlspool = swig_import_helper()
    del swig_import_helper
else:
    import _tlspool
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class error_data(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, error_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, error_data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["tlserrno"] = _tlspool.error_data_tlserrno_set
    __swig_getmethods__["tlserrno"] = _tlspool.error_data_tlserrno_get
    if _newclass:
        tlserrno = _swig_property(_tlspool.error_data_tlserrno_get, _tlspool.error_data_tlserrno_set)
    __swig_setmethods__["message"] = _tlspool.error_data_message_set
    __swig_getmethods__["message"] = _tlspool.error_data_message_get
    if _newclass:
        message = _swig_property(_tlspool.error_data_message_get, _tlspool.error_data_message_set)

    def __init__(self):
        this = _tlspool.new_error_data()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _tlspool.delete_error_data
    __del__ = lambda self: None
error_data_swigregister = _tlspool.error_data_swigregister
error_data_swigregister(error_data)

class ping_data(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ping_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ping_data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["YYYYMMDD_producer"] = _tlspool.ping_data_YYYYMMDD_producer_set
    __swig_getmethods__["YYYYMMDD_producer"] = _tlspool.ping_data_YYYYMMDD_producer_get
    if _newclass:
        YYYYMMDD_producer = _swig_property(_tlspool.ping_data_YYYYMMDD_producer_get, _tlspool.ping_data_YYYYMMDD_producer_set)
    __swig_setmethods__["facilities"] = _tlspool.ping_data_facilities_set
    __swig_getmethods__["facilities"] = _tlspool.ping_data_facilities_get
    if _newclass:
        facilities = _swig_property(_tlspool.ping_data_facilities_get, _tlspool.ping_data_facilities_set)

    def __init__(self):
        this = _tlspool.new_ping_data()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _tlspool.delete_ping_data
    __del__ = lambda self: None
ping_data_swigregister = _tlspool.ping_data_swigregister
ping_data_swigregister(ping_data)

class starttls_data(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, starttls_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, starttls_data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["flags"] = _tlspool.starttls_data_flags_set
    __swig_getmethods__["flags"] = _tlspool.starttls_data_flags_get
    if _newclass:
        flags = _swig_property(_tlspool.starttls_data_flags_get, _tlspool.starttls_data_flags_set)
    __swig_setmethods__["local"] = _tlspool.starttls_data_local_set
    __swig_getmethods__["local"] = _tlspool.starttls_data_local_get
    if _newclass:
        local = _swig_property(_tlspool.starttls_data_local_get, _tlspool.starttls_data_local_set)
    __swig_setmethods__["ipproto"] = _tlspool.starttls_data_ipproto_set
    __swig_getmethods__["ipproto"] = _tlspool.starttls_data_ipproto_get
    if _newclass:
        ipproto = _swig_property(_tlspool.starttls_data_ipproto_get, _tlspool.starttls_data_ipproto_set)
    __swig_setmethods__["streamid"] = _tlspool.starttls_data_streamid_set
    __swig_getmethods__["streamid"] = _tlspool.starttls_data_streamid_get
    if _newclass:
        streamid = _swig_property(_tlspool.starttls_data_streamid_get, _tlspool.starttls_data_streamid_set)
    __swig_setmethods__["localid"] = _tlspool.starttls_data_localid_set
    __swig_getmethods__["localid"] = _tlspool.starttls_data_localid_get
    if _newclass:
        localid = _swig_property(_tlspool.starttls_data_localid_get, _tlspool.starttls_data_localid_set)
    __swig_setmethods__["remoteid"] = _tlspool.starttls_data_remoteid_set
    __swig_getmethods__["remoteid"] = _tlspool.starttls_data_remoteid_get
    if _newclass:
        remoteid = _swig_property(_tlspool.starttls_data_remoteid_get, _tlspool.starttls_data_remoteid_set)
    __swig_setmethods__["ctlkey"] = _tlspool.starttls_data_ctlkey_set
    __swig_getmethods__["ctlkey"] = _tlspool.starttls_data_ctlkey_get
    if _newclass:
        ctlkey = _swig_property(_tlspool.starttls_data_ctlkey_get, _tlspool.starttls_data_ctlkey_set)
    __swig_setmethods__["service"] = _tlspool.starttls_data_service_set
    __swig_getmethods__["service"] = _tlspool.starttls_data_service_get
    if _newclass:
        service = _swig_property(_tlspool.starttls_data_service_get, _tlspool.starttls_data_service_set)
    __swig_setmethods__["timeout"] = _tlspool.starttls_data_timeout_set
    __swig_getmethods__["timeout"] = _tlspool.starttls_data_timeout_get
    if _newclass:
        timeout = _swig_property(_tlspool.starttls_data_timeout_get, _tlspool.starttls_data_timeout_set)

    def __init__(self):
        this = _tlspool.new_starttls_data()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _tlspool.delete_starttls_data
    __del__ = lambda self: None
starttls_data_swigregister = _tlspool.starttls_data_swigregister
starttls_data_swigregister(starttls_data)

class control_data(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, control_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, control_data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["flags"] = _tlspool.control_data_flags_set
    __swig_getmethods__["flags"] = _tlspool.control_data_flags_get
    if _newclass:
        flags = _swig_property(_tlspool.control_data_flags_get, _tlspool.control_data_flags_set)
    __swig_setmethods__["ctlkey"] = _tlspool.control_data_ctlkey_set
    __swig_getmethods__["ctlkey"] = _tlspool.control_data_ctlkey_get
    if _newclass:
        ctlkey = _swig_property(_tlspool.control_data_ctlkey_get, _tlspool.control_data_ctlkey_set)
    __swig_setmethods__["name"] = _tlspool.control_data_name_set
    __swig_getmethods__["name"] = _tlspool.control_data_name_get
    if _newclass:
        name = _swig_property(_tlspool.control_data_name_get, _tlspool.control_data_name_set)

    def __init__(self):
        this = _tlspool.new_control_data()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _tlspool.delete_control_data
    __del__ = lambda self: None
control_data_swigregister = _tlspool.control_data_swigregister
control_data_swigregister(control_data)

class prng_data(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, prng_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, prng_data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["in1_len"] = _tlspool.prng_data_in1_len_set
    __swig_getmethods__["in1_len"] = _tlspool.prng_data_in1_len_get
    if _newclass:
        in1_len = _swig_property(_tlspool.prng_data_in1_len_get, _tlspool.prng_data_in1_len_set)
    __swig_setmethods__["in2_len"] = _tlspool.prng_data_in2_len_set
    __swig_getmethods__["in2_len"] = _tlspool.prng_data_in2_len_get
    if _newclass:
        in2_len = _swig_property(_tlspool.prng_data_in2_len_get, _tlspool.prng_data_in2_len_set)
    __swig_setmethods__["prng_len"] = _tlspool.prng_data_prng_len_set
    __swig_getmethods__["prng_len"] = _tlspool.prng_data_prng_len_get
    if _newclass:
        prng_len = _swig_property(_tlspool.prng_data_prng_len_get, _tlspool.prng_data_prng_len_set)
    __swig_setmethods__["buffer"] = _tlspool.prng_data_buffer_set
    __swig_getmethods__["buffer"] = _tlspool.prng_data_buffer_get
    if _newclass:
        buffer = _swig_property(_tlspool.prng_data_buffer_get, _tlspool.prng_data_buffer_set)

    def __init__(self):
        this = _tlspool.new_prng_data()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _tlspool.delete_prng_data
    __del__ = lambda self: None
prng_data_swigregister = _tlspool.prng_data_swigregister
prng_data_swigregister(prng_data)

class socket_data(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, socket_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, socket_data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["unix_socket"] = _tlspool.socket_data_unix_socket_set
    __swig_getmethods__["unix_socket"] = _tlspool.socket_data_unix_socket_get
    if _newclass:
        unix_socket = _swig_property(_tlspool.socket_data_unix_socket_get, _tlspool.socket_data_unix_socket_set)

    def __init__(self):
        this = _tlspool.new_socket_data()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _tlspool.delete_socket_data
    __del__ = lambda self: None
socket_data_swigregister = _tlspool.socket_data_swigregister
socket_data_swigregister(socket_data)


def _pid(opt_pidfile):
    return _tlspool._pid(opt_pidfile)
_pid = _tlspool._pid

def _open_poolhandle(path):
    return _tlspool._open_poolhandle(path)
_open_poolhandle = _tlspool._open_poolhandle

def _ping(pingdata):
    return _tlspool._ping(pingdata)
_ping = _tlspool._ping

def _starttls(cryptfd, tlsdata, privdata, swig_null_callback):
    return _tlspool._starttls(cryptfd, tlsdata, privdata, swig_null_callback)
_starttls = _tlspool._starttls

def _control_detach(ctlkey):
    return _tlspool._control_detach(ctlkey)
_control_detach = _tlspool._control_detach

def _control_reattach(ctlkey):
    return _tlspool._control_reattach(ctlkey)
_control_reattach = _tlspool._control_reattach

def _prng(label, opt_ctxvalue, prng_len, prng_buf, ctlkey):
    return _tlspool._prng(label, opt_ctxvalue, prng_len, prng_buf, ctlkey)
_prng = _tlspool._prng

def tlspool_configvar(cfgfile, varname):
    return _tlspool.tlspool_configvar(cfgfile, varname)
tlspool_configvar = _tlspool.tlspool_configvar

def raise_errno():
    return _tlspool.raise_errno()
raise_errno = _tlspool.raise_errno



import os
import socket

if not 'IPPROTO_SCTP' in dir (socket):
	socket.IPPROTO_SCTP = 132


def pid (pidfile=None):
	"""This function returns the process identity of the TLS Pool.
	   When no pidfile is provided, the default path as configured in the
	   TLS Pool libary will be used.  An Exception is thrown when there is
	   no TLS Pool.
	"""
	process_id = _pid (pidfile)
	if process_id < 0:
		_tlspool.raise_errno ()
	else:
		return process_id

def open_poolhandle (path=None):
	"""This function returns the OS-specific socket handle value for the
	   TLS Pool.  It is already connected, and shared with the internal
	   management of this module, so it must not be closed by the caller.
	   When no path is provided, the default path is used instead.
	   This function blocks until a connection to the TLS Pool succeeds.
	   The path is only used in the first call, and only when no prior
	   contact to the TLS Pool has been made; if that has happened, then
	   this function returns the previously found socket handle.
	"""
	fd = _open_poolhandle (path)
	if fd < 0:
		_tlspool.raise_errno ()
	else:
		return fd

def ping (YYYYMMDD_producer=_tlspool.TLSPOOL_IDENTITY_V2,
			facilities=_tlspool.PIOF_FACILITY_ALL_CURRENT):
	"""This function takes in a string with a date in YYYYMMDD format, followed
	   by a user@domain producer identifier.  It takes in an integer value
	   that is the logical or of PIOF_FACILITY_xxx values.  This is sent to
	   the TLS Pool through tlspool_ping() and the response is returned as a
	   similar tuple (YYYYMMDD_producer, facilities) as returned by the
	   TLS Pool.  This function blocks until a connection to the TLS Pool has
	   been found.  It is a good first command to send to the TLS Pool.
	"""
	pp = ping_data ()
	pp.YYYYMMDD_producer = YYYYMMDD_producer
	pp.facilities = facilities
	if _ping (pp) < 0:
		_tlspool.raise_errno ()
	else:
		return (pp.YYYYMMDD_producer, pp.facilities)

def make_tlsdata (localid='', remoteid='',
		flags=0, local_flags=0,
		ipproto=socket.IPPROTO_TCP, streamid=0, service='',
		timeout=0, ctlkey='TODOTODOTODOTODO'):
	"""Make a new tlsdata structure, based the fields that may be supplied
	   as flags, or otherwise as defaults.  Note that the field "local" is
	   renamed to "local_flags" for reasons of clarity.  This helper function
	   returns a tlsdata structure or raises an exception.
	"""
	tlsdata = starttls_data ()
	if ctlkey is not None:
		tlsdata.ctlkey = ctlkey
	tlsdata.service = service
	tlsdata.localid = localid
	tlsdata.remoteid = remoteid
	tlsdata.flags = flags
	tlsdata.local = local_flags
	tlsdata.ipproto = ipproto
	tlsdata.streamid = streamid
	tlsdata.timeout = timeout
	return tlsdata

class Connection:
	"""The tlspool.Connection class wraps around a connection to be protected
	   by the TLS Pool.  It uses the global socket for attaching to the
	   TLS Pool, but the individual instances of this class do represent
	   individual connections managed by the TLS Pool.
	   New instances can already collect a large number of parameters
	   that end up in the tlsdata structure of tlspool_starttls(),
	   but these values may also be created through getters/setters.
	   Some values have reasonable defaults, but some must have been
	   set before invoking the starttls() method on the instance.
	   The tlsdata fields all have defaults, as specified under
	   tlspool.make_tlsdata().
	"""

	def __init__ (self, cryptsocket, plainsocket=None, **tlsdata):
		self.cryptsk = cryptsocket
		self.cryptfd = cryptsocket.fileno ()
		self.plainsk = plainsocket
		self.plainfd = plainsocket.fileno () if plainsocket else -1
		self.tlsdata = make_tlsdata (**tlsdata)

	def close (self):
		assert (self.plainsk is not None)
		assert (self.plainfd >= 0)
		self.plainsk.close ()
		self.plainsk = None
		self.plainfd = -1

	def tlsdata_get (self, tlsvar):
		return self.tlsdata [tlsvar]

	def tlsdata_set (self, tlsvar, value):
		self.tlsdata [tlsvar] = value

	def starttls (self):
		"""Initiate a TLS connection with the current settings, as
		   provided during instantiation or through getter/setter
		   access afterwards.  The variables that are required at
		   this point are service and, already obliged when making
		   a new instance, cryptfd.

                   Quoting the library documentation on file handles and
                   who should close them:

                   The cryptfd handle supplies the TLS connection that is
                   assumed to have been setup.  When the function ends,
                   either in success or failure, this handle will no longer
                   be available to the caller; the responsibility of closing
                   it is passed on to the function and/or the TLS Pool.

                   And on plainfd:  The file handle returned [in privdata],
                   if it is >= 0, should be closed by the caller, both in
                   case of success and failure.
		"""
		assert (self.cryptsk is not None)
		assert (self.cryptfd >= 0)
		assert (self.tlsdata.service != '')
		try:
			af = self.cryptsk.family
		except:
			af = socket.AF_INET
		try:
			if   self.cryptsk.proto in [socket.IPPROTO_UDP]:
				socktp = socket.SOCK_DGRAM
			elif self.cryptsk.proto in [socket.IPPROTO_SCTP]:
				socktp = socket.SOCK_SEQPACKET
			else:
				socktp = socket.SOCK_STREAM
		except:
			socktp = socket.SOCK_STREAM
		plainsockptr = socket_data ()
		plainsockptr.unix_socket = self.plainfd
# Clone cryptfd so _starttls() and Python can each close it
		unix_cryptfd = os.dup (self.cryptfd)
		if unix_cryptfd < 0:
			_tlspool.raise_errno ()
# We close cryptsk now and it will not repeat during garbage collection
		self.cryptsk.close ()
		self.cryptsk = None
		self.cryptfd = -1
# Provide None for the callback function, SWIG won't support it
# We might at some point desire a library of C routine options?
		rv = _starttls (unix_cryptfd, self.tlsdata, plainsockptr, None)
		self.plainfd = -1
		if rv < 0:
			_tlspool.raise_errno ()
		if self.plainsk is None:
			self.plainfd = plainsockptr.unix_socket
			self.plainsk = socket.fromfd (self.plainfd, af, socktp)
		return self.plainsk

	def prng (self, length, label, ctxvalue=None):
		"""Produce length bytes of randomness from the master key, after
		   mixing it with the label and optional context value in ctxvalue.
		   The procedure has been described in RFC 5705.
#TODO# Find a way to return the random bytes, and use the length
		"""
		assert (length > 0)
		assert (1 <= len (label) <= 254)
		assert (1 <= len (ctxvalue or 'X') <= 254)
		buf = prng_data ()
# buf.in1_len = len (label)
# buf.in2_len = len (ctxvalue) if ctxvalue is not None else 255
# buf.prng_len = length
		rv = _prng (label, ctxvalue, length, buf.buffer, self.tlsdata.ctlkey)
		if rv < 0:
			_tlspool.raise_errno ()
		else:
			return buf.buffer [:length]

	def control_detach (self):
		"""Detach control of this connection.  Although the connection
		   itself will still be available, control over it is diminished
		   and its continuation is no longer dependent on the current
		   connection.  You may need to pass tlsdata.ctlkey to another
		   process, or use control_reattach(), before this is reversed
		   in this process or another.
		"""
		_control_detach (self.tlsdata.ctlkey)

	def control_reattach (self, ctlkey=None):
		"""Reattach control of this connection.  The connection may have
		   called control_detach() in this process or another.  To help
		   with the latter case, its tlsdata.ctlkey must have been moved
		   into this instance.
		"""
		_control_reattach (self.tlsdata.ctlkey)

class SecurityMixIn:
	"""The SecurityMixIn class can be added as a subclass before a
	   (subclass of) SocketServer.BaseServer and it adds the facilities
	   of starttls(), startgss() and startssh() which add security through
	   one of the mechanisms.  In addition, have_xxx() can be used to
	   query in advance if startxxx() should be doable with the present
	   combination of TLS Pool and client code.

	   Set a tlsdata field in the subclass, using the tlspool.make_tlsdata()
	   helper function, to bootstrap the same kind of behaviour on all
	   clients for which this class will be instantiated.  Such a tlsdata
	   class variable will automatically be cloned into instances.
	   Example code:

		from tlspool import SecurityMixIn
		from SocketServer import BaseHandler

		class MyHandler (SecurityMixIn, BaseHandler):

			tlsdata = make_tlsdata (service=...)

			def handle (self):
				...
				self.starttls ()

			def handle_secure (self):
				...

	   Alternatively, you can setup the tlsdata structure, or any part of it,
	   at a later time, through the tlsdata variable that will then be
	   instantiated during object initialisation.  Any such changes to fields
	   must be completed before invoking starttls() on this object.
	"""

	_pingdata = None
	tlsdata = None

	def __init__ (self):
		if self.tlsdata is None:
			self.tlsdata = make_tlsdata ()

	def have_tls (self):
		"""Check whether STARTTLS is supported on the current TLS Pool"""
		if self._pingdata is None:
			self._pingdata = ping ()
		return (self._pingdata [1] & PIOF_FACILITY_STARTTLS) != 0

	def have_ssh (self):
		"""Check whether STARTSSH is supported on the current TLS Pool"""
		if self._pingdata is None:
			self._pingdata = ping ()
		return (self._pingdata [1] & PIOF_FACILITY_STARTSSH) != 0

	def have_gss (self):
		"""Check whether STARTGSS is supported on the current TLS Pool"""
		if self._pingdata is None:
			self._pingdata = ping ()
		return (self._pingdata [1] & PIOF_FACILITY_STARTGSS) != 0

	def starttls (self):
		"""Modify the current socket to make it a TLS socket.  Use the
		   tlsdata as currently setup (see class-level documentation).
		   Afterwards, call handle_secure() to start from scratch with
		   a secure connection.  Also see the man page on the underlying
		   C library call, tlspool_starttls(3).

		   Some protocols start TLS immediately, for instance HTTPS;
		   for such protocols, the handle() method would immediately
		   call starttls() and the actual handler code would move
		   into secure_handle().

		   Other protocols, such as XMPP and IMAP, start in plaintext
		   and exchange pleasantries until they agree on running TLS.
		   This is the point where starttls() can be invoked.

		   The methods startssh() and startgss() are place holders for
		   future alternatives to start other security wrappers than
		   TLS, after negotiating them in a manner similar to STARTTLS.
		"""
		if type (self.request) == tuple:
			sox = self.request [1]
		else:
			sox = self.request
		assert (type (sox) == socket._socketobject)
		try:
			af = sox.family
		except:
			af = socket.AF_INET
		try:
			if   sox.proto in [socket.IPPROTO_UDP]:
				socktp = socket.SOCK_DGRAM
			elif sox.proto in [socket.IPPROTO_SCTP]:
				socktp = socket.SOCK_SEQPACKET
			else:
				socktp = socket.SOCK_STREAM
		except:
			socktp = socket.SOCK_STREAM
		plainsockptr = socket_data ()
		plainsockptr.unix_socket = -1
		unix_sox = os.dup (sox.fileno ())
		if unix_sox < 0:
			_tlspool.raise_errno ()
		sox.close ()
		rv = _starttls (unix_sox, self.tlsdata, plainsockptr, None)
		if rv < 0:
			_tlspool.raise_errno ()
		assert (plainsockptr.unix_socket >= 0)
		sox2 = socket.fromfd (plainsockptr.unix_socket, af, socktp)
# Now, since socket.fromfd() used os.dup(), we close the original
		os.close (plainsockptr.unix_socket)
		plainsockptr.unix_socket = -1
		if type (self.request) == tuple:
#TODO# This is not permitted, editing a tuple
			self.request [1] = sox2
		else:
			self.request     = sox2
		self.handle_secure ()

	def startssh (self):
		raise NotImplementedError ("Python wrapper does not implement STARTSSH")

	def startgss (self):
		raise NotImplementedError ("Python wrapper does not implement STARTGSS")

	def handle (self):
		"""When not overridden, the handle() method replaces the one in
		   later-mentioned classes in the inheritance structure.  This
		   means that this is the default behaviour when the SecureMixIn
		   precedes the handler class.  This particular version of handle()
		   does nothing but invoke starttls(), which in turn invokes
		   handle_secure() after the TLS handshake has succeeded.
		"""
		self.starttls ()

	def handle_secure (self):
		"""This method may be overridden to handle the secure part of the
		   connection, after starttls() has been called from within
		   handle().  This function is special in the sense that it may
		   refer to self.tlsdata and rely on the localid and remoteid
		   as being negotiated over TLS.

		   Since any prior actions in handle() are usually unauthenticated,
		   it is common to start from scratch with the protocol.  The secure
		   layer however, tends to enable more features, such as blunt
		   password submission and, perhaps, privileged operations available
		   to the authenticated self.tlsdata.remoteid user.

		   As an example, if the handler class is BaseHTTPRequestHandler,
		   its handle() method could be invoked on the secured content
		   (possibly after authorisation) with an override as follows:

			def handle_secure (self):
				BaseHTTPRequestHandler.handle (self)
		"""
		pass


PIOC_CONTROL_DETACH_V2 = _tlspool.PIOC_CONTROL_DETACH_V2
PIOC_CONTROL_REATTACH_V2 = _tlspool.PIOC_CONTROL_REATTACH_V2
PIOC_ERROR_V2 = _tlspool.PIOC_ERROR_V2
PIOC_LIDENTRY_CALLBACK_V2 = _tlspool.PIOC_LIDENTRY_CALLBACK_V2
PIOC_LIDENTRY_REGISTER_V2 = _tlspool.PIOC_LIDENTRY_REGISTER_V2
PIOC_LOCAL = _tlspool.PIOC_LOCAL
PIOC_PINENTRY_V2 = _tlspool.PIOC_PINENTRY_V2
PIOC_PING_V2 = _tlspool.PIOC_PING_V2
PIOC_PLAINTEXT_CONNECT_V2 = _tlspool.PIOC_PLAINTEXT_CONNECT_V2
PIOC_PRNG_V2 = _tlspool.PIOC_PRNG_V2
PIOC_STARTTLS_LOCALID_V2 = _tlspool.PIOC_STARTTLS_LOCALID_V2
PIOC_STARTTLS_V2 = _tlspool.PIOC_STARTTLS_V2
PIOC_SUCCESS_V2 = _tlspool.PIOC_SUCCESS_V2
PIOF_FACILITY_ALL_CURRENT = _tlspool.PIOF_FACILITY_ALL_CURRENT
PIOF_FACILITY_STARTGSS = _tlspool.PIOF_FACILITY_STARTGSS
PIOF_FACILITY_STARTSSH = _tlspool.PIOF_FACILITY_STARTSSH
PIOF_FACILITY_STARTTLS = _tlspool.PIOF_FACILITY_STARTTLS
PIOF_LIDENTRY_DBAPPEND = _tlspool.PIOF_LIDENTRY_DBAPPEND
PIOF_LIDENTRY_DBENTRY = _tlspool.PIOF_LIDENTRY_DBENTRY
PIOF_LIDENTRY_DBINSERT = _tlspool.PIOF_LIDENTRY_DBINSERT
PIOF_LIDENTRY_DBREORDER = _tlspool.PIOF_LIDENTRY_DBREORDER
PIOF_LIDENTRY_NEW = _tlspool.PIOF_LIDENTRY_NEW
PIOF_LIDENTRY_ONTHEFLY = _tlspool.PIOF_LIDENTRY_ONTHEFLY
PIOF_LIDENTRY_REGFLAGS = _tlspool.PIOF_LIDENTRY_REGFLAGS
PIOF_LIDENTRY_SKIP_DBENTRY = _tlspool.PIOF_LIDENTRY_SKIP_DBENTRY
PIOF_LIDENTRY_SKIP_DOMAIN_ONEUP = _tlspool.PIOF_LIDENTRY_SKIP_DOMAIN_ONEUP
PIOF_LIDENTRY_SKIP_DOMAIN_SAME = _tlspool.PIOF_LIDENTRY_SKIP_DOMAIN_SAME
PIOF_LIDENTRY_SKIP_DOMAIN_SUB = _tlspool.PIOF_LIDENTRY_SKIP_DOMAIN_SUB
PIOF_LIDENTRY_SKIP_NOTROOT = _tlspool.PIOF_LIDENTRY_SKIP_NOTROOT
PIOF_LIDENTRY_SKIP_USER = _tlspool.PIOF_LIDENTRY_SKIP_USER
PIOF_LIDENTRY_WANT_DBENTRY = _tlspool.PIOF_LIDENTRY_WANT_DBENTRY
PIOF_STARTTLS_BOTHROLES_PEER = _tlspool.PIOF_STARTTLS_BOTHROLES_PEER
PIOF_STARTTLS_DETACH = _tlspool.PIOF_STARTTLS_DETACH
PIOF_STARTTLS_DOMAIN_REPRESENTS_USER = _tlspool.PIOF_STARTTLS_DOMAIN_REPRESENTS_USER
PIOF_STARTTLS_DTLS = _tlspool.PIOF_STARTTLS_DTLS
PIOF_STARTTLS_FORK = _tlspool.PIOF_STARTTLS_FORK
PIOF_STARTTLS_IGNORE_CACHES = _tlspool.PIOF_STARTTLS_IGNORE_CACHES
PIOF_STARTTLS_IGNORE_REMOTEID = _tlspool.PIOF_STARTTLS_IGNORE_REMOTEID
PIOF_STARTTLS_LOCALID_CHECK = _tlspool.PIOF_STARTTLS_LOCALID_CHECK
PIOF_STARTTLS_LOCALID_ONTHEFLY = _tlspool.PIOF_STARTTLS_LOCALID_ONTHEFLY
PIOF_STARTTLS_LOCALROLE_CLIENT = _tlspool.PIOF_STARTTLS_LOCALROLE_CLIENT
PIOF_STARTTLS_LOCALROLE_PEER = _tlspool.PIOF_STARTTLS_LOCALROLE_PEER
PIOF_STARTTLS_LOCALROLE_SERVER = _tlspool.PIOF_STARTTLS_LOCALROLE_SERVER
PIOF_STARTTLS_REMOTEROLE_CLIENT = _tlspool.PIOF_STARTTLS_REMOTEROLE_CLIENT
PIOF_STARTTLS_REMOTEROLE_PEER = _tlspool.PIOF_STARTTLS_REMOTEROLE_PEER
PIOF_STARTTLS_REMOTEROLE_SERVER = _tlspool.PIOF_STARTTLS_REMOTEROLE_SERVER
PIOF_STARTTLS_RENEGOTIATE = _tlspool.PIOF_STARTTLS_RENEGOTIATE
PIOF_STARTTLS_REQUEST_REMOTEID = _tlspool.PIOF_STARTTLS_REQUEST_REMOTEID
PIOF_STARTTLS_WITHOUT_SNI = _tlspool.PIOF_STARTTLS_WITHOUT_SNI
TLSPOOL_CTLKEYLEN = _tlspool.TLSPOOL_CTLKEYLEN
TLSPOOL_DEFAULT_CONFIG_PATH = _tlspool.TLSPOOL_DEFAULT_CONFIG_PATH
TLSPOOL_DEFAULT_PIDFILE_PATH = _tlspool.TLSPOOL_DEFAULT_PIDFILE_PATH
TLSPOOL_DEFAULT_SOCKET_PATH = _tlspool.TLSPOOL_DEFAULT_SOCKET_PATH
TLSPOOL_IDENTITY_V2 = _tlspool.TLSPOOL_IDENTITY_V2
TLSPOOL_PRNGBUFLEN = _tlspool.TLSPOOL_PRNGBUFLEN
TLSPOOL_SERVICELEN = _tlspool.TLSPOOL_SERVICELEN
TLSPOOL_TIMEOUT_DEFAULT = _tlspool.TLSPOOL_TIMEOUT_DEFAULT
# This file is compatible with both classic and new-style classes.


